# Kafka

要点

- 消息模型
- 消息传输担保机制

## 消息模型

Kafka 也是使用的标准的发布-订阅模型。与 [RocketMQ](RocketMQ.md) 类似。唯一的区别是 Kafka 中队列不叫队列，而叫做分片（Partition），含义和功能是一样的。

**Kafka 能否保证消息的顺序消费？**

根据 Kafka 的消息模型，同一个主题下的每一条消息会发送到不同分片上，不同分片之间是并行消费的，因此一个主题是不能保证消费顺序的，但是每个分片之内是可以保证消费顺序的。

### 持久性

Kafka 使用文件存储消息，这就直接决定 Kafka 在性能上严重依赖文件系统的本身特性。且无论任何操作系统下，对文件系统本身的优化几乎没有可能。文件缓存/直接内存映射等是常用的手段。因为 Kafka 是对日志文件进行 append 操作，因此磁盘检索的开支是较小的。同时为了减少磁盘写入的次数，broker 会将消息暂时缓存起来，当消息的个数（或尺寸）达到一定阀值时，再写入到磁盘，这样减少了磁盘 IO 调用的次数。

### 性能

需要考虑的影响性能点很多，除磁盘 IO 之外，我们还需要考虑网络 IO，这直接关系到 Kafka 的吞吐量问题。

Kafka 并没有提供太多高超的技巧，对于生产者，可以将消息缓存起来，当消息的条数达到一定阀值时，批量发送给 broker；对于消费者也是一样，批量 fetch 多条消息。不过消息量的大小可以通过配置文件来指定。对于 Kafka broker 端，似乎有个 sendfile 系统调用可以潜在的提升网络 IO 的性能：将文件的数据映射到系统内存中，socket直接读取相应的内存区域即可，而无需进程再次copy和交换。

其实对于 producer/consumer/broker 三者而言，CPU 的开支应该都不大，因此启用消息压缩机制是一个良好的策略。压缩需要消耗少量的 CPU 资源，不过对于 Kafka 而言，网络 IO 更应该需要考虑。可以将任何在网络上传输的消息都经过压缩。Kafka支持 gzip/snappy 等多种压缩方式。

### 生产

Kafka 中消息被发送到哪个分片由生产者自己来决定。生产者可以使用随机、哈希、轮询等方式来决定把消息发送到哪个分片。生产者将会和主题下所有 partition leader 保持 socket 连接。消息由生产者直接通过 socket 发送到 broker，中间不会经过任何“路由层”。其中 partition leader 的位置（host:port）注册在 zookeeper 中，生产者作为 zookeeper 客户端，已经注册了 watch 用来监听 partition leader 的变更事件。

Kafka 支持异步发送，将多条消息暂且在客户端缓存起来，并将他们批量的发送到 broker，小数据 IO 太多，会拖慢整体的网络延迟，批量延迟发送事实上提升了网络效率。不过这也有一定的隐患，比如说当生产者失效时，那些尚未发送的消息将会丢失。

### 消费

消费者向 broker 发送 fetch 请求，并告知其获取消息的偏移量 offset。此后消费者将会获得一定条数的消息。消费者也可以重置 offset 来重新消费消息。

Kafka 采用 pull 模式来消费消息，这样的好处是消费者可以根据自己的消费能力来消费消息数据，并且可以自己控制消费的 offset。

Kafka 由消费者自己来控制 offset，消费者可以在本地保存最后消费的 offset，并定期向 zookeeper 注册 offset。

## 消息传输担保机制

Kafka 有三种消息传输担保机制，默认保证消息收发层面上

- **at-most-once**：发送一次，无论成败，将不会重发。
- **at-least-once**：消息至少发送一次，如果消息未能接受成功，可能会重发，直到接收成功。这个通常是首选，相比于 at-most-once 而言，重复接收数据总比丢失数据要好。
- **exactly-once**：消息只会发送一次。这种方式 Kafka 并没有严格实现。

## 复制

Kafka 将每个分片数据复制到多个服务器上，任何一个分片有一个 leader 和多个 follower （可以没有）。备份的个数可以通过 broker 配置文件来设定。leader 处理所有的读写请求，follower 需要和 leader 保持同步。follower 和消费者一样，消费消息并保存在本地日志中。leader 负责跟踪所有的 follower 状态，如果 follower 落后太多或者失效，leader 将会把它从 replicas 同步列表中删除。

当所有的 follower 都将一条消息保存成功，此消息才被认为是 committed，那么此时消费者才能消费它。即使只有一个 replicas 实例存活，仍然可以保证消息的正常发送和接收，只要 zookeeper 集群存活即可。（不同于其他分布式存储，比如 hbase 需要多数存活才行）

当 leader 失效时，需在 followers 中选取出新的 leader，可能此时 follower 落后于 leader，因此需要选择一个 **up-to-date** 的 follower。选择 follower 时需要兼顾一个问题，就是新 leader 上所已经承载的 partition leader 的个数，如果一个服务器上有过多的 partition leader，意味着此服务器将承受着更多的 IO 压力。在选举新 leader 时，需要考虑到**负载均衡**。

