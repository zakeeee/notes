# 数据库-锁

[TOC]

## MyISAM 与 InnoDB 在锁方面的区别

- MyISAM 默认用的是表级锁，不支持行级锁。
- InnoDB 默认用的是行级锁，也支持表级锁。

InnoDB 的行锁是通过给索引上的索引项加锁来实现的。这就意味着，**只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁**。

## InnoDB 可重复读隔离级别下如何避免幻读

表象：快照读（非阻塞读）—— MVCC（Multi-Version Concurrency Control）
内在：next-key锁（行锁+Gap锁）

**当前读和快照读**

- 当前读：select ... in share mode, select ... for update, update, delete, insert
- 快照读：不加锁的非阻塞读，select

```sql
# 在 REPEATABLE READ 下，事务首次执行快照读的时机会影响后续读取结果，创建快照的时机决定了读取事务的版本，快照读还是有避免幻读的能力

# 先快照再修改
select * from account where id = 1;  # 事务 1 先快照读
update account set balance = 0 where id = 1;  # 事务 2 执行修改
select * from account where id = 1;  # 事务 1 再次读取时，读的是快照，不是事务 2 修改后的值
select * from account where id = 1 lock in share mode;  # 事务 1 执行当前读，则会读到事务 2 修改后的值

# 先修改再快照
update account set balance = 0 where id = 1;  # 事务 2 先执行修改
select * from account where id = 1;  # 事务 1 快照读，此时读到的是事务 2 修改后的值
```

READ COMMITTED 级别下，总是读取行的最新版本，如果行被锁定，就读取该行版本的一个最新的快照。
REPEATABLE READ 级别下，总是读取这个事务开始时的行数据。

**RC、RR 级别下的 InnoDB 的非阻塞读如何实现**

- 数据行里的 DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID 字段
- Undo 日志
- Read View

![Image(17)](_v_images/20190724105145712_7460.png)

- **DB_TRX_ID**：最近一次对本行记录做修改的事务 ID。
- **DB_ROLL_PTR**：回滚指针，写入回滚段 rollback segment 的 undo 日志记录。
- **DB_ROW_ID**：行号。

Undo记录：存储旧版本数据。

**next-key 锁（行锁 + Gap 锁）**

Gap 锁在 READ UNCOMMITTED 和 READ COMMITTED 下没有，在 REPEATABLE READ 和 SERIALIZABLE 下默认有。

Gap 锁会锁住一个范围内的记录，但不包括记录本身。行锁只会锁住确定的某条记录。

对于主键索引或者唯一索引

- 如果 where 条件全部命中，则不会加 Gap 锁，只会加行锁。
- 如果 where 条件部分命中或者都没命中，则会加 Gap 锁。

![Image(18)](_v_images/20190724105448867_27633.png)

非唯一索引：锁住 (6, 11] 区间，注意如果此时插入 ("dd", 6)，name 是主键，即使 id 不在区间内，但是 "dd" 按照字母顺序在 "f" 前面，插入时还是会锁住。

![Image(19)](_v_images/20190724105502160_234.png)

## 两阶段锁协议

两阶段锁协议（2PL，Two Phase Locking）规定加锁和解锁分为两个阶段执行：

- 对任何数据的读写之前，必须申请对该数据加锁。
- 在释放一个锁后，事务不再申请和获得其他任何锁。

遵循两阶段锁协议的事务的交叉调度是可串行化的。但是可串行化的若干事务未必遵循两阶段锁协议。

另外遵循两阶段锁协议的事务也可能发生死锁，比如互相企图获得对方占有的锁。

## 死锁产生的原因

### 事务之间对资源访问顺序的交替

事务 T1 修改记录 A，在记录 A 上加了排他锁，然后又想修改记录 B；事务 T2 修改记录 B，在记录 B 上加了排他锁，然后企图修改记录 A。这时两个事务都互相持有对方需要的资源，且都无法释放自己的资源，因此导致了死锁。

解决方案：

这种死锁比较常见，是由于程序的 BUG 产生的，除了调整的程序的逻辑没有其它的办法。仔细分析程序的逻辑，对于数据库的多表操作时，尽量按照相同的顺序进行处理，尽量避免同时锁定两个资源，如操作 A 和 B 两张表时，总是按先 A 后 B 的顺序处理， 必须同时锁定两个资源时，要保证在任何时刻都应该按照相同的顺序来锁定资源。

### 并发修改同一条记录

事务 T1 查询一条记录，并企图该条记录，事务 T2 同时也查询一条记录，并企图修改该记录。这时事务 T1 需要将共享锁升级为排他锁，需要等待事务 T2 释放共享锁，同理事务 T2 也需要将共享锁升级为排他锁，也需要等待事务 T1 释放共享锁。这样两个事务都无法继续，产生死锁。

解决方案：

1. 使用乐观锁进行控制。乐观锁大多是基于数据版本（Version）记录机制实现。即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个“version”字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。乐观锁机制避免了长事务中的数据库加锁开销（用户 A 和用户 B 操作过程中，都没有对数据库数据加锁），大大提升了大并发量下的系统整体性能表现。Hibernate 在其数据访问引擎中内置了乐观锁实现。需要注意的是，由于乐观锁机制是在我们的系统中实现，来自外部系统的用户更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。
2. 使用悲观锁进行控制。悲观锁大多数情况下依靠数据库的锁机制实现，如 Oracle 的 `SELECT … FOR UPDATE` 语句，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。如一个金融系统，当某个操作员读取用户的数据，并在读出的用户数据的基础上进行修改时（如更改用户账户余额），如果采用悲观锁机制，也就意味着整个操作过程中（从操作员读出数据、开始修改直至提交修改结果的全过程，甚至还包括操作员中途去煮咖啡的时间），数据库记录始终处于加锁状态，可以想见，如果面对成百上千个并发，这样的情况将导致灾难性的后果。所以，采用悲观锁进行控制时一定要考虑清楚。
