# 死锁发生的原因

[TOC]

## 事务之间对资源访问顺序的交替

### 产生原因

事务 T1 修改记录 A，在记录 A 上加了排他锁，然后又想修改记录 B；事务 T2 修改记录 B，在记录 B 上加了排他锁，然后企图修改记录 A。这时两个事务都互相持有对方需要的资源，且都无法释放自己的资源，因此导致了死锁。

### 解决方案

这种死锁比较常见，是由于程序的 BUG 产生的，除了调整的程序的逻辑没有其它的办法。仔细分析程序的逻辑，对于数据库的多表操作时，尽量按照相同的顺序进行处理，尽量避免同时锁定两个资源，如操作 A 和 B 两张表时，总是按先 A 后 B 的顺序处理， 必须同时锁定两个资源时，要保证在任何时刻都应该按照相同的顺序来锁定资源。

## 并发修改同一条记录

### 产生原因

事务 T1 查询一条记录，并企图该条记录，事务 T2 同时也查询一条记录，并企图修改该记录。这时事务 T1 需要将共享锁升级为排他锁，需要等待事务 T2 释放共享锁，同理事务 T2 也需要将共享锁升级为排他锁，也需要等待事务 T1 释放共享锁。这样两个事务都无法继续，产生死锁。

### 解决方案

1. 使用乐观锁进行控制。乐观锁大多是基于数据版本（Version）记录机制实现。即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个“version”字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。乐观锁机制避免了长事务中的数据库加锁开销（用户 A 和用户 B 操作过程中，都没有对数据库数据加锁），大大提升了大并发量下的系统整体性能表现。Hibernate 在其数据访问引擎中内置了乐观锁实现。需要注意的是，由于乐观锁机制是在我们的系统中实现，来自外部系统的用户更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。
2. 使用悲观锁进行控制。悲观锁大多数情况下依靠数据库的锁机制实现，如 Oracle 的 `select … for update` 语句，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。如一个金融系统，当某个操作员读取用户的数据，并在读出的用户数据的基础上进行修改时（如更改用户账户余额），如果采用悲观锁机制，也就意味着整个操作过程中（从操作员读出数据、开始修改直至提交修改结果的全过程，甚至还包括操作员中途去煮咖啡的时间），数据库记录始终处于加锁状态，可以想见，如果面对成百上千个并发，这样的情况将导致灾难性的后果。所以，采用悲观锁进行控制时一定要考虑清楚。

## 索引不当导致全表扫描

### 产生原因

如果在事务中执行了一条不满足条件的语句，执行全表扫描，把行级锁上升为表级锁，多个这样的事务执行后，就很容易产生死锁和阻塞。类似的情况还有当表中的数据量非常庞大而索引建的过少或不合适的时候，使得经常发生全表扫描，最终应用系统会越来越慢，最终发生阻塞或死锁。

### 解决方案

SQL 语句中不要使用太复杂的关联多表的查询：使用 `EXPLAIN` 对 SQL 语句进行分析，对于有全表扫描的 SQL 语句，建立相应的索引进行优化。

## 事务封锁范围大且相互等待

[参考这篇文章](https://blog.csdn.net/qq_16681169/article/details/73359670)
