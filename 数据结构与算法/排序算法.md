# 排序算法

要点：

- O(N^2) 复杂度的排序算法
- O(NlogN) 复杂度的排序算法
- O(N) 复杂度的排序算法

## O(N^2) 复杂度的排序算法

下面三种排序均为基于比较的排序算法，也都是原地排序算法（空间复杂度为O(1)）。

### 冒泡排序

将未排序数组中的元素从前往后两两比较，如果前一个元素比后一个元素大，就交换，直到未排序数组的末尾为止，这样一次过程称为一次冒泡，可以保证未排序数组中最大的元素被冒泡到末尾。冒泡排序是稳定的排序算法，因为对于值相等的两个元素，不会交换他们。

冒泡排序中当某次冒泡过程没有发生数据交换，则表示数据已经排好序，就不用继续下去了。

当数组中元素已经是有序的时候，我们只要遍历一次，发现没有发生数据交换，就停止，因此最好复杂度是O(n)。如果数组是逆序的，需要遍历N次，因此最坏复杂度是O(n^2)。通过引入有序度来分析可以得到平均时间复杂度为O(n^2)。

### 插入排序

将未排序区间的下一个元素插入到已排序区间的合适位置，并将已排序区间中在插入点之后的全部向后移动，这是一次插入。重复N次插入后，数组变为有序。插入排序是稳定的排序，如果原数组中有相同大小的元素，则排序后他们的先后次序保持原来的次序。

当数组中元素已经是有序的时候，每次插入操作只要比较一次，因此最好复杂度是O(n)。而如果数组是逆序的，每次插入都要插入到数组头部，需要O(n)的时间复杂度，重复N次，因此最坏时间复杂度是O(n^2)。

由于插入排序的数据移动操作较冒泡排序的数据交换操作步骤少，因此同样是O(n^2)的复杂度时，常数项较小，因此效率更好。

### 选择排序

在未排序区间中选出最小的元素，放到已排序区间的末尾，这是一次选择。重复N次选择后，数组变为有序。选择排序是不稳定的排序算法，比如对[5, 3, 4, 5, 2, 6]进行选择排序时，2和前面的5交换后，两个5的前后次序就变了。

选择排序最好、最坏和平均时间复杂度都为O(n^2)。


## O(NlogN) 复杂度的排序算法

O(NlogN) 复杂度的两种排序算法都是递归排序，**都利用了分治的思想**。

### 归并排序

归并排序有**分解**和**合并**两个步骤。

```
// 归并排序算法, A 是数组，n 表示数组大小
merge_sort(A, n) {
  merge_sort_c(A, 0, n-1)
}

// 递归调用函数
merge_sort_c(A, p, r) {
  // 递归终止条件
  if p >= r  then return

  // 取 p 到 r 之间的中间位置 q
  q = (p+r) / 2
  // 分治递归
  merge_sort_c(A, p, q)
  merge_sort_c(A, q+1, r)
  // 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]
  merge(A[p...r], A[p...q], A[q+1...r])
}

merge(A[p...r], A[p...q], A[q+1...r]) {
  var i := p，j := q+1，k := 0 // 初始化变量 i, j, k
  var tmp := new array[0...r-p] // 申请一个大小跟 A[p...r] 一样的临时数组
  while i<=q AND j<=r do {
    if A[i] <= A[j] {
      tmp[k++] = A[i++] // i++ 等于 i:=i+1
    } else {
      tmp[k++] = A[j++]
    }
  }

  // 判断哪个子数组中有剩余的数据
  var start := i，end := q
  if j<=r then start := j, end:=r

  // 将剩余的数据拷贝到临时数组 tmp
  while start <= end do {
    tmp[k++] = A[start++]
  }

  // 将 tmp 中的数组拷贝回 A[p...r]
  for i:=0 to r-p do {
    A[p+i] = tmp[i]
  }
}

```

归并排序是稳定的排序。

时间复杂度最好最坏和平均都是O(nlogn)，与有序度无关。空间复杂度由于需要一个临时数组，因此为O(n)。

### 快速排序

```
// 快速排序，A 是数组，n 表示数组的大小
quick_sort(A, n) {
  quick_sort_c(A, 0, n-1)
}
// 快速排序递归函数，p,r 为下标
quick_sort_c(A, p, r) {
  if p >= r then return

  q = partition(A, p, r) // 获取分区点
  quick_sort_c(A, p, q-1)
  quick_sort_c(A, q+1, r)
}

partition(A, p, r) {
  pivot := A[r]
  i := p
  for j := p to r-1 do {
    if A[j] < pivot {
      swap A[i] with A[j]
      i := i+1
    }
  }
  swap A[i] with A[r]
  return i
}
```

快速排序不稳定。时间复杂度最好和平均为O(nlogn)，最坏为O(n^2)。空间复杂度为O(1)，是原地排序。

## O(N) 复杂度的排序算法

O(N) 复杂度的排序算法都**不是基于比较**的排序算法，而且只能用在数据具有一定特点的数据集上，**并非适合任何数据的排序**。

### 桶排序

### 计数排序

### 基数排序
