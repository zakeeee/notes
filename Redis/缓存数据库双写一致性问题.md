# 缓存数据库双写一致性问题

要点：

- 一致性问题产生原因
- 解决方案

## 一致性问题产生原因

由于写数据库和写缓存是两个操作，是非原子性的，有可能两个操作一个成功一个失败，这就导致数据库和缓存中的数据的不一致问题。

## 解决方案

### 读请求和写请求串行化

[读请求和写请求串行化](https://www.javazhiyin.com/22969.html)

[数据库与缓存更新与读取操作进行异步串行化](https://zq99299.github.io/note-book/cache-pdp/037.html#为什么上亿流量高并发场景下，缓存会出现这个问题？)

### 先更新数据库，再更新缓存

这套方案，小编认为大多数场景不合适。为什么呢？主要从以下几个原因讲解：

一、资源浪费

在一些大型的信息网站中（博客、贴吧），我们引入缓存主要是对热数据（请求频繁的）进行缓存，而这时候，如果很多用户对于冷数据（长时间没人访问，或者访问量很少）进行更新，然后再去更新缓存，这就造成了缓存资源的大量浪费（因为访问量少，导致这些缓存命中低，浪费缓存资源）。

二、脏数据

这是由于出现了并发操作的原因导致的，如：同时有两个请求A和B对数据进行了更新操作，由于网络原因，可能存在以下情况：

请求A更新了数据库；
请求B更新了数据库；
请求B更新了缓存；
请求A更新了缓存。
这就出现了A数据覆盖了B数据的情况，此时就产生了脏数据，如果没有缓存定时过期机制，此时的脏数据需要等待下一次的更新，才会对缓存进行更新，虽然用户看到数据出现问题，会再重新更新一次，但这已经有多了一次不必要的请求了，写请求量大的时候，容易造成众多不必要的更新请求。

三、请求时间

如果缓存不是一种简单的数据缓存，而是需要经过较为复杂的运算，才能得出缓存值，这时候，请求将会在计算缓存值上，耗费一部分时间，而这就导致了请求的响应时间变长，增加系统的负担，降低了系统的处理能力。

四、频繁写入

在写请求很多，而读请求很少的场景下，缓存没起到多大的作用，就给频繁更新了，造成了资源浪费，如：

对数据A进行了一次修改，生成了缓存A；
此时没有读取数据A的请求；
对数据A进行了一次修改，更新了缓存A；
此时没有读取数据A的请求；
对数据A进行了一次修改；
此时有了读取数据A的请求。
这时就会造成缓存的不必要更新操作（没有人读取缓存），用户量大的时候，会造成大量的不必要操作，造成系统资源的浪费。

适合场景

当然，这种也不是说就不能使用这些，既然存在，就有其存在的道理。一下的场景就适合：

- 读请求占据网站的总流量的99%；
- 网站数据量不大（几十万的文章数据）；
- 很少会去更新数据（一般文章写好后，不会去更新）。

案例

1. 个人博客
2. 手册网站（w3cschool、菜鸟教程等）

[缓存数据库双写一致性问题](https://zhuanlan.zhihu.com/p/37549923)

### 先更新数据库，再删除缓存

这种策略比较多平台使用，如：Facebook。但是这种策略也存在一些问题，如：

一、脏数据

造成脏数据的原因主要由并发引起，如：

用户A请求数据A
数据A缓存失效
用户A从数据库中得到旧数据数据A
用户B更新了数据A（新数据）
用户B删除了缓存
用户A将查到旧数据写入了缓存
此时就产生了脏数据，虽然这种概率非常小，但对于更新不频繁的网站来说，此时的脏数据就是个很严重的错误。

二、缓存删除失败

用户A更新了数据A
用户A删除数据A的缓存失败
用户B读到数据A缓存的旧数据
此时就产生了数据不一致的问题。

解决方案

设置缓存的有效时间（最简单的方案）

优点：

- 简单
- 易操作

缺点：

- 会存在短时间内的旧数据
- 如果数据量太多，缓存有效时间短，容易发生一段时间内缓存大量失效，此时的数据库压力突然剧增，引发缓存雪崩现象（缓存有效时间为随机值减少发生缓存雪崩的可能性）

消息队列（比较复杂，需要引入消息队列系统）

步骤：

更新数据库；
删除缓存失败；
将需要删除的Key发送到消息队列；
隔断时间从消息队列中拉取要删除的key；
继续删除，直至成功为止。

优点：

- 不会引发缓存雪崩
- 只删除需要删除的缓存

缺点：

- 引入了消息系统（增加了系统的复杂性）

### 先删除缓存，再更新数据库

这种方法也是比较多人使用的，但是也会出现脏数据的问题：

原因

用户A删除缓存失败
用户A成功更新了数据

或者

用户A删除了缓存；
用户B读取缓存，缓存不存在；
用户B从数据库拿到旧数据；
用户B更新了缓存；
用户A更新了数据。

以上两种情况都能造成脏数据的产生。

解决方案

设置缓存的有效时间（最简单的方案）

优点：

- 简单
- 易操作

缺点：

- 会存在短时间内的旧数据
- 如果数据量太多，缓存有效时间短，容易发生一段时间内缓存大量失效，此时的数据库压力突然剧增，引发缓存雪崩现象（缓存有效时间为随机值减少发生缓存雪崩的可能性）

消息队列

先淘汰缓存；
更新数据库；
将需要淘汰的缓存Key发送到消息队列；
另起一程序拉取消息队列的数据；
对需要删除的key进行删除，直至删除为止。

优点：

- 保证了缓存的删除
- 不会增加更新的处理时间
- 不会引发缓存雪崩

缺点：

- 会增加一次缓存miss（可以忽略不计）
- 引入了消息系统（增加了系统的复杂性）
