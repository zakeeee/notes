# Redis

## 为什么要用 Redis（缓存）

如果不用缓存，只用数据库的话，由于数据库查询速度较慢，一旦并发请求数较多，会导致数据库无法承受，使得系统的响应速度下降甚至系统挂掉。

使用缓存有如下好处：

1. 高性能：Redis（缓存）将数据存储在内存中，从内存中读取数据比使用数据库从硬盘中读取数据要快得多。
2. 高并发：缓存能承受的并发请求连接数比数据库大得多。

## Redis 为什么快

1. 使用 C 语言开发，执行效率高。
2. 纯内存访问，速度比读取磁盘快很多个数量级。
3. 数据结构类型简单，对数据的操作也简单，不像关系型数据库各种约束。
4. 采用单线程模型：（1）单线程简化算法的实现，并发的数据结构实现不但困难且测试也麻烦。（2）单线程避免了线程切换以及加锁和释放锁带来的消耗。这里的单线程只是处理请求是单线程，而不是整个 Redis 进程只有一个线程。
5. 使用多路 IO 复用函数，以 Linux 系统中为例，Redis 使用 epoll 作为 IO 多路复用技术的实现，再加上 Redis 自身的事件处理模型将 epoll 的 read、write、close 等都转换成事件，不在网络 IO 上浪费过多的时间。实现对多个文件描述符 FD 读写的监控，提高性能。

**Redis 如何选择采用哪种 IO 多路复用函数（epoll/kqueue/evport/select）**

- 因地制宜，根据操作系统的不同选择不同的多路复用函数。
- 优先选择时间复杂度为 O(1) 的 IO 多路复用函数作为底层实现。
- 以时间复杂度 O(n) 的 select 作为保底。
- 基于 react 设计模式监听 IO 事件。

## Redis 支持的数据类型

> 除了下面 5 种常用数据类型外，Redis 还支持用于计数的 HyperLogLog，用于存储地理位置信息的 Geo 等。

### 1. String

简单的 key-value 类型，value 除了可以是 string 也可以是数字。

- 底层实现：如果能转为整数就使用整数，否则使用简单动态字符串。
- 适用场景：缓存一个字符串或者数字。

### 2. List

List 是由多个 string 组成的列表，里面的元素按照插入的先后顺序有序排列。

- 底层实现：初始时使用压缩列表，数据量大时转为双向链表。
- 适用场景：缓存一个列表，实现一个队列。

### 3. Set

Set 是由多个 string 组成的集合，与 List 不同的是，Set 中的 string 都是不重复且无序的。可以使用 Set 轻松实现对两个数据集进行求交集、并集、差集的操作。比如社交网站求两个人共同好友或者共同关注的人。

- 底层实现：集合中只有整数且数量不多时使用整数集合，数据量大时使用字典。
- 适用场景：缓存一个集合。

### 4. Sorted Set

与 Set 类似，但是增加了一个浮点数值 score，Sorted Set 中的元素都是按照 score 排序的，也正因为如此可以获取一个范围内的元素。

- 底层实现：数据量小时只用跳表，数据量大时使用跳表（有序性）+字典（查找快）。
- 适用场景：缓存一个集合，但要保证数据有序的情况。

### 5. Hash

Hash 是由多个 fields 和 values 组成的映射表，其中 field 和 value 都是 string。Hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。

- 底层实现：初始时使用压缩列表（按照 `| field1 | value1 | field2 | value2 | ... |` 这样的顺序存放来存储），数据量大时使用字典。
- 适用场景：缓存一个对象。

## Redis 底层数据类型基础

1. 简单动态字符串 SDS（Simple Dynamic String）：Redis 没有直接使用 C 语言传统的字符串表示，而是自己构建了一种名为简单动态字符串（simple dynamic string SDS）的抽象类型，并将 SDS 用作 Redis 的默认字符串表示。
2. 链表 Linked List：双向链表。
3. 字典 Dict
4. 跳表 Skip List：Redis 只在两个地方用到了跳跃表，一个是实现**有序集合键**，另外一个是在**集群节点中用作内部数据结构**。
5. 整数集合 Int Set：整数集合是**集合键**的底层实现之一，当一个集合中只包含整数，且这个集合中的元素数量不多时，redis 就会使用整数集合 Int Set 作为集合的底层实现。
6. 压缩列表 Zip List：压缩列表是列表键和哈希键的底层实现之一。当一个列表键只含有少量列表项，并且每个列表项要么就是小整数，要么就是长度比较短的字符串，那么 Redis 就会使用压缩列表来做列表键的底层实现。
7. 对象

**SDS 对比 C 语言字符串有什么优点？**

```c
struct sdshdr {
    // 记录 buf 数组中已经使用的字节数
    // 等于 SDS 所保存的字符串长度
    int len;

    // 记录 buf 数组中未使用字节的数量
    int free;

    // 字节数组，用于保存字符串
    char buf[];
}
```

- 以 O(1) 的时间复杂度获取字符串长度，这是因为 SDS 用了一个 `len` 变量保存字符串长度。
- 杜绝缓冲区溢出，每次进行字符串拼接都会先检查 `buf` 容量是否足够。
- 减少修改字符串长度时所需要的内存重分配次数，SDS 使用了 `free` 来记录 `buf` 中没有使用的字节数，如果要拼接的字符串长度小于 `free`，就可以直接拼接，不需要重新分配内存。如果要扩展，有两种情况：如果扩展后 `len` 小于 1MB，则 `free` 的空间也扩展 `len` 的长度；如果大于 1MB，则 `free` 的空间扩展 1MB。
- 二进制安全，SDS 不光可以用来存字符串，还可以存任何二进制的数据，数据的长度以 `len` 定义，而不是以 `'\0'` 作为结束。
- 兼容部分 C 的字符串函数。

## Redis 内存管理

[Redis 内存管理.md](Redis内存管理.md)

## Redis 管道

Redis 提供了批量执行命令的方法，即使用管道（Pipeline）。

- Pipeline 和 Linux 的管道类似。
- Redis 基于请求/响应模型，单个请求处理需要一一应答。
- Pipeline 批量执行指令，节省多次 IO 往返的时间。
- 有顺序依赖的指令建议分批发送。

## Redis 的同步机制

### 主从同步

**主从模式的弊端是无法保证高可用性，一旦 leader 挂掉，Redis 无法对外提供写入操作。**

#### 全同步

1. follower 发送 sync 命令到 leader。
2. leader 启动一个后台进程，将 Redis 中的数据快照保存到文件中（bgsave）。
3. leader 将保存数据快照过程中收到的写命令缓存起来。
4. leader 完成写文件操作后，将该文件发给从节点。
5. follower 接受到文件后保存在磁盘中，然后加载文件到内存中去恢复数据快照。
6. leader 将这期间收集的增量写命令发送给从节点，进行回放。

#### 增量同步

1. leader 接收到用户的操作指令，判断是否要传播到从节点（一般增删改需要，查询不需要）。
2. 将操作记录追加到 AOF 文件。
3. 将操作扩散到其他 follower：对其主从库，确保 follower 是该操作对应的结点；往响应缓存写入指令。
4. 将缓存中的数据发给 follower。

### Redis Sentinel（哨兵）

哨兵的存在是为了解决主从同步 leader 宕机后的主从切换问题。其具有如下功能：

- **监控**：检查主从服务器是否运行正常。
- **提醒**：通过 API 向管理员或其他应用程序发送故障通知。
- **自动故障迁移**：主从切换。

## Redis 集群

为了从海量数据里快速找到所需数据，可以将数据分片存储在多个结点上，通常使用计算哈希值然后取模来决定数据应该映射到哪个结点上。

如果只是对结点数量取模，那么一旦结点数量改变，数据映射就会出错。为了解决这个问题，引入了[一致性哈希算法](../数据结构与算法/一致性哈希算法.md)。

## 相关阅读

[Redis 到底快在哪里](https://mp.weixin.qq.com/s?__biz=MjM5NTY1MjY0MQ==&mid=2650745383&idx=3&sn=c7546a9ad8d23a51505f332d428fec34&chksm=befebf698989367ffff100dcde67785d1fbeceff4c814fba2a93443c967d39775b58cd78c92f&mpshare=1&scene=1&srcid=#rd)

[深入浅出 Redis-redis 底层数据结构（上）](https://www.cnblogs.com/jaycekon/p/6227442.html)

[深入浅出 Redis-redis 底层数据结构（下）](https://www.cnblogs.com/jaycekon/p/6277653.html)
