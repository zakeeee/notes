# Redis

## 为什么要用 Redis（缓存）

如果不用缓存，只用数据库的话，由于数据库查询速度较慢，一旦并发请求数较多，会导致数据库无法承受，使得系统的响应速度下降甚至系统挂掉。使用缓存有如下好处：

1. 高性能：Redis（缓存）将数据存储在内存中，从内存中读取数据比使用数据库从硬盘中读取数据要快得多。
2. 高并发：缓存能承受的并发请求连接数比数据库大得多。

## Redis 为什么快

1. C 语言开发，执行效率高。
2. 纯内存访问，速度比读取磁盘快很多个数量级。
3. 数据结构类型简单，对数据的操作也简单，不像关系型数据库各种约束。
4. 单线程：第一，单线程简化算法的实现，并发的数据结构实现不但困难且测试也麻烦。第二，单线程避免了线程切换以及加锁释放锁带来的消耗，对于服务端开发来说，锁和线程切换通常是性能杀手。这里的单线程只是处理请求是单线程，而不是整个 Redis 进程只有一个线程。
5. 非阻塞多路 IO 复用：以 Linux 系统中为例，Redis 使用 epoll 作为 IO 多路复用技术的实现，再加上 Redis 自身的事件处理模型将 epoll 的 read、write、close 等都转换成事件，不在网络 IO 上浪费过多的时间。实现对多个文件描述符 FD 读写的监控，提高性能。

**Redis 如何选择采用哪种 IO 多路复用函数（epoll/kqueue/evport/select）**

- 因地制宜，根据操作系统的不同选择不同的多路复用函数。
- 优先选择时间复杂度为 O(1) 的 IO 多路复用函数作为底层实现。
- 以时间复杂度 O(n) 的 select 作为保底。
- 基于 react 设计模式监听 IO 事件。

[搞懂Redis到底快在哪里](https://mp.weixin.qq.com/s?__biz=MjM5NTY1MjY0MQ==&mid=2650745383&idx=3&sn=c7546a9ad8d23a51505f332d428fec34&chksm=befebf698989367ffff100dcde67785d1fbeceff4c814fba2a93443c967d39775b58cd78c92f&mpshare=1&scene=1&srcid=#rd)

## Redis 支持的数据类型

> 除了下面 5 种常用数据类型外，Redis 还支持用于计数的 HyperLogLog，用于存储地理位置信息的 Geo 等。

### 1. String

简单的 key-value 类型，value 除了可以是 string 也可以是数字。

- 底层实现：如果能转为整数就使用整数，否则使用简单动态字符串。
- 适用场景：缓存一个字符串或者数字。

### 2. List

list 是一个列表，里面的元素按照插入的先后顺序有序排列。list 中的元素可以是重复的。

- 底层实现：初始时使用压缩列表，数据量大时转为双向链表。
- 适用场景：缓存一个列表，实现一个队列。

### 3. Hash

hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。

- 底层实现：初始时使用压缩列表（按照 `| key1 | value1 | key2 | value2 | ... |` 这样的顺序存放来存储），数据量大时使用字典。
- 适用场景：缓存一个对象。

### 4. Set

set 是一个集合，其中的元素都是不重复的，但不能保证元素在集合内的顺序。可以使用 set 轻松实现对两个数据集进行求交集、并集、差集的操作。比如社交网站求两个人共同好友或者共同关注的人。

- 底层实现：集合中只有整数且数量不多时使用整数集合，数据量大时使用字典。
- 适用场景：缓存一个集合。

### 5. SortedSet

和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列。

- 底层实现：数据量小时只用跳表，数据量大时使用跳表（有序性）+字典（查找快）。
- 适用场景：缓存一个集合，但要保证数据有序的情况。

## Redis 底层数据类型基础

1. **简单动态字符串 SDS（Simple Dynamic String）**：Redis 没有直接使用C语言传统的字符串表示，而是自己构建了一种名为简单动态字符串（simple dynamic string SDS）的抽象类型，并将SDS用作Redis 的默认字符串表示。
2. **链表 Linked List**：双向链表。
3. **字典 Dict**
4. **跳表 Skip List**：Redis 只在两个地方用到了跳跃表，一个是实现**有序集合键**，另外一个是在**集群节点中用作内部数据结构**。
5. **整数集合 Int Set**：整数集合是**集合键**的底层实现之一，当一个集合中只包含整数，且这个集合中的元素数量不多时，redis就会使用整数集合 Int Set 作为集合的底层实现。
6. **压缩列表 Zip List**：压缩列表是列表键和哈希键的底层实现之一。当一个列表键只含有少量列表项，并且每个列表项要么就是小整数，要么就是长度比较短的字符串，那么Redis 就会使用压缩列表来做列表键的底层实现。
7. **对象**

[深入浅出Redis-redis底层数据结构（上）](https://www.cnblogs.com/jaycekon/p/6227442.html)
[深入浅出Redis-redis底层数据结构（下）](https://www.cnblogs.com/jaycekon/p/6277653.html)

## Redis 内存管理

[Redis内存管理.md](Redis内存管理.md)

## 缓存雪崩和缓存穿透

[缓存雪崩和缓存穿透.md](缓存雪崩和缓存穿透.md)

## Pipeline

Redis 提供了批量执行命令的方法，即使用 pipeline。

- Pipeline 和 Linux 的管道类似。
- Redis 基于请求/响应模型，单个请求处理需要一一应答。
- Pipeline 批量执行指令，节省多次 IO 往返的时间。
- 有顺序依赖的指令建议分批发送。

## Redis 的同步机制

### 主从同步

**主从模式的弊端是无法保证高可用性，一旦 leader 挂掉，Redis 无法对外提供写入操作。**

#### 全同步

1. follower 发送 sync 命令到 leader。
2. leader 启动一个后台进程，将 Redis 中的数据快照保存到文件中（bgsave）。
3. leader 将保存数据快照过程中收到的写命令缓存起来。
4. leader 完成写文件操作后，将该文件发给从节点。
5. follower 接受到文件后保存在磁盘中，然后加载文件到内存中去恢复数据快照。
6. leader 将这期间收集的增量写命令发送给从节点，进行回放。

#### 增量同步

1. leader 接收到用户的操作指令，判断是否要传播到从节点（一般增删改需要，查询不需要）。
2. 将操作记录追加到 AOF 文件。
3. 将操作扩散到其他 follower：对其主从库，确保 follower 是该操作对应的结点；往响应缓存写入指令。
4. 将缓存中的数据发给 follower。

### Redis Sentinel

哨兵的存在是为了解决主从同步 leader 宕机后的主从切换问题。其具有如下功能：

- **监控**：检查主从服务器是否运行正常。
- **提醒**：通过API向管理员或其他应用程序发送故障通知。
- **自动故障迁移**：主从切换。

## Redis 集群

为了从海量数据里快速找到所需数据，可以将数据分片存储在多个结点上，通常使用计算哈希值然后取模来决定数据应该映射到哪个结点上。

如果只是对结点数量取模，那么一旦结点数量改变，数据映射就会出错。为了解决这个问题，引入了**一致性哈希算法**。

### 一致性哈希算法

一致性哈希算法不是对结点数量取模，而是对一个固定的值（Redis 是 2^32）取模，将哈希值空间组织成虚拟的圆环。

![](_v_images/20190724143130202_20664.png)

将结点的某个属性进行hash运算，映射到这个圆环上。

![](_v_images/20190724143228068_23476.png)

数据进行hash运算，映射到圆环上，然后顺时针找到最近的一个存储节点，存储到该结点上。

![](_v_images/20190724143407625_7286.png)

假设Node C宕机，那么数据会映射到下一个最近的结点即Node D上。只有宕机结点到其逆时针最近的结点之间的数据会受到影响（映射到Node B和Node C之间的那些数据）会受到影响。

![](_v_images/20190724143503503_14019.png)

如果新增了一个结点Node X，此时Node A，Node B和Node D仍然不会受到影响。只有新增结点到其逆时针最近的结点之间的数据会受影响（映射到Node B 和 Node X 之间的那些数据）。

![](_v_images/20190724143714209_3349.png)

可以看出通过引入一致性哈希算法，不管增减结点都只需要对一小部分数据进行重新处理。提高了可用性和扩展性。

一致性哈希算法还有个问题就是**数据倾斜问题**。

![](_v_images/20190724144133834_10655.png)

当存储结点很少时，可能出现如上图所示，大量数据存储到 Node A 而少量存储到 Node B，导致倾斜。

解决方法是引入虚拟结点，对每个服务结点映射到多个位置，好比有了多个服务结点。最终存储时根据虚拟结点找到真实结点然后存储。实际中虚拟结点数量通常设置为32甚至更高。

![](_v_images/20190724144242343_2029.png)
