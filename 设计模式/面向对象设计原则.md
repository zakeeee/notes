# 面向对象设计原则

## SOLID 原则

SOLID 原则由以下五个原则构成。

### Single Responsibility Principle 单一职责原则

字面理解就是每一个类或模块应该只负责一个职责。

个人理解这个单一职责并不限定只做一件事，可以是一些功能集合，并且这些功能具有高度的相关性，也就是**高内聚**。好比现实中的各种职业，每种职业都不是只做一件事，而是做一些相关程度非常高的事。

当这个类与其他类只是简单的合作关系，可以很容易将这种合作关系进行替换时，也就是**低耦合**。

### Open-Close Principle 开闭原则

- 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。
- 类模块应该是可扩展的，但是不可修改。

简单来说就是基于某个模块开发新功能时，应该只需要在其基础上扩展，不需要对原来的程序进行修改。这样可以保证兼容性。可以通过继承或组合的方式来扩展功能，并且通过一致的接口保证原有的功能不变。

### Liskov Substitution Principle 里式替换原则

简单说就是使用父类的地方，可以在不改变程序正确性的前提下用其任意子类去替换。也就是说对于这个替换的地方而言，子类应该与父类具有一致的行为，替换不能破坏现有的行为。

### Interface Segregation Principle 接口隔离原则

- 用户不应该依赖它不需要的接口。
- 类间的依赖关系应该建立在最小的的接口上。

简单来说就是接口应该粒度更细，如果接口非常庞大，可以拆分为多个细粒度的接口，这样保证使用这个接口的类不会得到不需要的方法。

例如有一个接口 A，有三个方法。如果某个类 C 只需要用到其中的方法 1 和方法 2，不需要方法 3，那么就可以把接口 A 拆分为 A1 和 A2，类 C 只依赖接口 A1。

```ts
// 拆分前
interface A {
  method1();
  method2();
  method3();
}

// 拆分后
interface A1 {
  method1();
  method2();
}

interface A2 {
  method3();
}

interface A extends A1, A2 {}
```

接口的设计粒度越小系统越灵活，但是接口太多会使得程序结构复杂，维护难度大且不易读。因此需要根据实际情况来设计。

### Dependence Inversion Principle 依赖倒置原则

- 高层模块不应该依赖低层模块，二者都应该依赖于抽象。
- 抽象不应该依赖实现细节，实现细节应该依赖抽象。

第一条说的是高层模块不应依赖具体的低层模块，否则一旦需要替换低层模块时，高层模块可能也需要修改。高层模块应该依赖低层模块的抽象，比如接口，这样不论低层模块如何更换，只要这个抽象不变，高层模块就不需要修改。

第二条说的是设计某个低层模块的抽象时不应该依赖具体的实现细节，应该设计好抽象后再去根据它去实现具体细节。

## 其他原则

### 多用组合，少用继承

“接口 + 组合”的方式相比于继承更加灵活。在继承中父类和子类之间存在耦合关系，而组合中两个类之间的耦合度非常低，只需要接口一致。
