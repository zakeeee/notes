# 面向对象设计原则

[TOC]

## 1. 依赖倒置原则（Dependence Inversion Principle）

- 高层模块（稳定）不应该依赖低层模块（变化），二者都应该依赖于抽象（稳定）。
- 抽象（稳定）不应该依赖实现细节（变化），实现细节应该依赖抽象（稳定）。

主要思想就是：如果一个类中的一个成员或者参数为一个具体的类型，那么这个类就依赖这个具体类型。如果在一个继承结构中，上层类中的一个成员或者参数为一个下层类型，那么就是这个继承结构高层依赖低层，就要尽量面向抽象或者接口编程。

举例：存在一个 Driver 类，成员为一个 Car 对象，还有一个 drive 方法，Car 对象中有两个方法 start 与 stop。显然 Driver 依赖 Car，也就是说 Driver 类调用了 Car 类中的方法。但是当增加 Driver 类对于 Bus 类的支持时（司机有需要开公交车），就必须更改 Driver 中的代码，就破坏了开放封闭原则。根本原因在于高层的的 Driver 类与低层的 Car 类仅仅的耦合在一起的。解决方法之一就是：对 Car 类和 Bus 类进行抽象，引入抽象类 Automobile。而 Car 和 Bus 则是对 Automobile 的泛化。

经过这样的改造发现，原本的高层依赖低层，变成了高层与低层同时依赖抽象。这就是依赖倒转原则的本质。

## 2. 开放封闭原则（Open-Close Principle）

- 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。
- 类模块应该是可扩展的，但是不可修改。

开闭原则被称为面向对象设计的基石，实际上，其他原则都可以看作是实现开闭原则的工具和手段。通俗来说就是，开发一个软件时，应该对其进行功能扩展，而在进行这些扩展时，不需要对原来的程序进行修改。

这样做的好处是，软件可用性非常灵活，扩展性强。需要新的功能时，可以增加新的模块来满足新需求。另外由于原来的模块没有修改，所以不用担心稳定性的问题。

## 3. 单一职责原则（Single-Responsibilitiy Principle）

对一个类而言，应该仅有一个引起它变化的原因。如果存在多于一个动机去改变一个类，那么这个类就具有多于一个的职责，就应该把多余的职责分离出去，再去创建一些类来完成每一个职责。

举个例子：一个人身兼数职，而这些事情相关性不大，甚至有冲突，那他就无法很好的解决这些问题职责，应该分到不同的人身上去做。

单一职责原则是实现高内聚低耦合的最好方法，没有之一。

## 4. 里式替换原则（Liskov Substitution Principle）

子类可以扩展父类的功能，但是不能改变父类原有的功能。

在开闭原则中，主张“抽象”和“多态”。维持设计的封装性“抽象”是语言提供的功能，“多态”由继承语意实现。因此如何去度量继承关系中的质量？答案就是继承必须明确确保超类（父类）所拥有的性质在子类中仍然成立。

在面向对象的思想中，一个对象就是一组状态和一系列行为的组合体。状态是对象的内在特性，行为是对象的外在特性。里式替换原则表述的就是在同一继承体系中的对象应该具有共同的行为特征。

## 5. 接口隔离原则（Interface Segregation Principle）

用于恰当的划分角色和接口，具有两种含义：1、用户不应该依赖它不需要的接口；2、类间的依赖关系应该建立在最小的的接口上。

将这两个定义概括为一句话：建立单一接口，代替庞大臃肿的接口。通俗来说就是：接口尽量细化，同时保证接口中的方法尽量的少。一个接口中包含太多的行为时，会导致它们与客户端的不正常依赖关系，要做的就是分离接口，从而实现解耦。

回到上述的单一职责原则，要求行为分离接口接口细化，感觉有些相同。但实际上，单一职责原则要求类与接口的职责单一，注重的是职责，没有要求接口尽量的少。

在接口隔离原则中，要求尽量使用多个专门的接口。专门的接口也就是提供给多个模块的接口。提供给几个模块就应该有几个接口，而不是建立一个臃肿庞大的接口，所有的模块都可以访问。

但是接口的设计是有限度的。接口的设计粒度越小系统越灵活，这是事实，但是接口太多这也就使得结构复杂，维护难度大。因此实际中，怎样把握就靠开发的经验和常识了。

## 6. 多用组合，少用继承

- 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。
- 继承在某种程度上破坏了封装性，子类父类耦合度高。
- 对象组合只要求被组合的对象具有良好定义的接口，耦合度低。

## 7. 封装变化点

使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。

## 8. 针对接口编程，而不是针对实现编程

- 不将变量类型声明为某个特定的具体类，而是声明为某个接口。
- 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。
- 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案。