# Java 并发

要点：

- 锁的类型
- volatile有什么用
- synchronized和Lock的区别
- ReentrantLock实现原理
- notify 和 notifyAll 的区别
- start 和 run 的区别
- CAS

## 锁的类型

- 可重入锁：已经获得该锁的对象可以再次获得该锁；
- 可中断锁：可以在等待获取锁的过程中中断；
- 公平锁：按照线程等待锁的时间来调整获取锁的优先级，等待时间越长的线程优先级越高，正因为如此，公平锁需要频繁线程切换；**非公平锁**相反，可以减少线程频繁切换，提高吞吐量，但非公平锁会存在“线程饥饿”的问题，可能某个线程很长时间都拿不到锁，一直等待；
- 读写锁：读和写分开处理的锁，允许多个线程同时读，但是写的时候必须同步；
- 自旋锁：有的等待获取锁只需要等待很短的时间，这种时候如果频繁切换线程开销较大，因此可以让一个线程反复尝试获得锁，也就是自旋；
- 乐观锁：总是假定别的线程不会修改，只是提交操作时检查数据是否被修改过；**悲观锁**相反，总是假定别人会修改，因此每次提交操作前都要上锁；

## volatile有什么用

一旦一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后，那么就具备了两层语义：

1. 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
2. 禁止进行指令重排序。

通过 volatile 修饰的变量可以保证线程之间的可见性，但并不能保证这3个指令的原子执行，在多线程并发执行下，无法做到线程安全，得到正确的结果。

## synchronized和Lock的区别

- synchronized 是关键字，同步功能由 jvm 实现；Lock是接口；
- Lock 可以尝试获得锁，线程可以不用一直等待；synchronized 不能；
- synchronized 在同步代码执行完毕或者抛出异常时会释放锁；Lock 要手动释放锁；
- synchronized 无法判断锁的状态；Lock 可以判断锁的状态；
- synchronized 可重入，不可中断，非公平；Lock 可重入，可中断，可公平；
- synchronized 少量同步；Lock 大量同步；

## ReentrantLock实现原理

重入意味着获取锁的粒度是线程。要想支持重入性，就要解决两个问题：

1. 在线程获取锁的时候，如果已经获取锁的线程是当前线程的话则直接再次获取成功；
2. 由于锁会被获取n次，那么只有锁在被释放同样的n次之后，该锁才算是完全释放成功。

在尝试获取锁时，判断当前锁是否被占用，如果没有被占用，就直接获取（如果使用公平锁，在尝试获取锁的时候还要判断同步队列中是否有优先级在当前线程之前的，如果有则获取失败）；如果被占用了，判断占用者是否是当前线程，如果是，就将计数加1，相当于再次获得锁，如果不是，就获取失败。
在尝试释放锁时，将计数减1，如果计数变为0，锁就被完全释放了。

## notify 和 notifyAll 的区别

当线程调用一个共享对象的wait后，该调用线程被挂起，进入等待池。

notify 随机唤醒一个等待池中的线程到锁池中。
notifyAll 唤醒所有等待池中的线程到锁池中。

**notify 可能导致死锁。**

## start 和 run 的区别

调用 `thread.start()` 后会在新的线程中执行 `run()` 方法，不会阻塞当前线程。而直接调用 `run()` 则是在当前调用线程中执行，可能会阻塞当前线程。

## CAS

Java 中 atomic 包下的类是利用 CAS 来实现原子性操作的（Compare And Swap），CAS 实际上是利用处理器提供的 CMPXCHG 指令实现的，而处理器执行 CMPXCHG 指令是一个原子性操作。

CAS 的思想很简单：三个参数，一个当前内存值 V、旧的预期值 A、即将更新的值 B，当且仅当预期值 A 和内存值 V 相同时，将内存值修改为 B 并返回 true，否则什么都不做，并返回 false。

CAS 存在一个很明显的问题，即 ABA 问题。如果变量 V 初次读取的时候是 A，并且在准备赋值的时候检查到它仍然是 A，那能说明它的值没有被其他线程修改过了吗？
如果在这段期间曾经被改成 B，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。针对这种情况，java 并发包中提供了一个带有标记的原子引用类 AtomicStampedReference，它可以通过控制变量值的版本来保证 CAS 的正确性。