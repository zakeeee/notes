# JVM 垃圾回收

## 判断一个对象是否可以回收的方法

### 1. 引用计数法

当一个对象被引用时，它的引用计数增加 1，反之，当引用失效时引用计数减 1。

如果两个对象互相引用，那么他们的引用计数都不会是 0，这种情况下虚拟机无法判断是否需要回收这两个对象。正因为如此，现在的虚拟机都不使用这种方法。

### 2. 可达性分析法

现在主流的虚拟机都是采用可达性分析法来判断对象是否需要被回收的。可达性分析法以 GC Roots 对象为起点，以树状向下查找，走过的路径为“引用链”，没有与引用链相连的对象就是不可用的。Java 中可以作为 GC Roots 的对象：

- 虚拟机栈(栈桢中的本地变量表)中的引用的对象
- 方法区中的类静态属性引用的对象
- 方法区中的常量引用的对象
- 本地方法栈中 JNI 的引用的对象

注：并不是不可达的对象就必须 "死"，他们还是处于"缓刑"， 真正要宣告一个对象死亡，需要经过两次标记的过程：经过可达性分析后对象没有和 GC Roots 连接的引用链，那么需要被标记一次然后还需要经过筛选（筛选条件：判断该对象是否有必要执行 finalize 方法），如果对象已经调用了或者没有覆盖 finalize 方法（finalize 方法只会被执行一次！），那么虚拟机判定该对象是 "没有必要执行该方法"。

如果该对象有必要执行 finalize 方法，那么对象会被放置在一个叫做 F-Queue 的队列之中，之后会由虚拟机自动建立，由低优先级的 Finalize 方法去执行。（执行时只去触发对象的 finalize 方法，但是并不等待他运行结束，防止有的对象 finalize 进行缓慢，或者死循环，会导致队列持续等待，进而内存回收系统崩溃。）稍后 GC 会对 F-Queue 队列中的对象进行第二次标记，当 finalize 方法执行后成功将对象连接到引用链上任何一个对象，那么这个对象就被拯救成功了，不然则被回收。

### 3. 方法区回收

因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。

#### 常量的回收

相当于这个常量已经废弃了。比如常量池中有一个字符串对象"abc"，当系统中没有字符串引用这个对象时，那么这个常量在 GC 时将被回收。

#### 类的卸载

类的卸载条件很多，需要满足以下三个条件，并且**满足了条件也不一定会被卸载**：

- 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。
- 加载该类的 ClassLoader 已经被回收。
- 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。

### 4. finalize 方法

类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。

当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。

## 垃圾回收算法

### 标记-清除算法

![](_v_images/20190724100908538_17231.png)

分为标记和清除两个阶段：

1. 清除：对没有标记的对象进行回收并清除标志位，并且会判断回收分块与前一个空闲分块是否连续，如果连续就合并这两个分块。
2. 标记：检查每个对象是否为存活对象，如果是存活对象就打上标记。

回收就是把对象作为分块连接到“空闲链表”这个单向链表上，之后遍历这个链表就可以找到分块。

缺点：标记和清除的效率不高，会产生内存碎片。

### 标记-整理算法

![](_v_images/20190724100915728_13164.png)

根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

优点：不会产生内存碎片。
缺点：需要移动大量对象，处理效率比较低。

### 复制算法

![](_v_images/20190724100924189_7690.png)

将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。

优点：回收简单，不会产生内存碎片。
缺点：需要移动对象，只用了一半的内存空间。

现在的商用虚拟机都用这种方法回收新生代，但不是分为大小相等的两块，而是**一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor**。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。

HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间**分配担保**，也就是借用老年代的空间存储放不下的对象。

### 分代收集算法

当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。

## Full GC和Minor GC

### Minor GC

只回收新生代，由于新生代存活时间短，因此 Minor GC 会频繁执行，速度一般比较快。

### Full GC

回收新生代和老年代，由于老年代存活时间长，因此 Full GC 很少执行，速度也比 Minor GC 慢很多。

### Full GC 触发条件

#### 1. 调用 System.gc()

#### 2. 老年代空间不足

#### 3. 空间分配担保失败

#### 4. JDK 1.7 以前的永久代空间不足

#### 5. Concurrent Mode Failure

## 垃圾收集器

![](_v_images/20190724100834679_14262.png)

以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。

- 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；
- 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。

